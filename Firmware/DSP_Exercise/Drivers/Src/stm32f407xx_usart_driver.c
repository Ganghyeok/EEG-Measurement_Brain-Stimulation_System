/*
 * stm32f407xx_usart_driver.c
 *
 *  Created on: 2021. 3. 8.
 *      Author: Ganghyeok Lim
 */

#include "stm32f407xx.h"


static void UART_SetConfig(UART_HandleTypeDef *pUSARTHandle);
static void UART_DMATransmitCplt(DMA_HandleTypeDef *pUSARTHandle);

void UART_Init(UART_HandleTypeDef *pUSARTHandle)
{
	/* Init the low level hardware : GPIO, CLOCK */
	UART_MspInit(pUSARTHandle);

	/* Disable the peripheral */
	UART_DISABLE(pUSARTHandle);

	/* Set the UART Communication parameters */
	UART_SetConfig(pUSARTHandle);

	/* In asynchronous mode, the following bits must be kept cleared */
	CLEAR_BIT(pUSARTHandle->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
	CLEAR_BIT(pUSARTHandle->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));

	/* Enable the peripheral */
	UART_ENABLE(pUSARTHandle);

	// Init the USART state
	pUSARTHandle->State = USART_STATE_READY;
}


__weak void UART_MspInit(UART_HandleTypeDef *pUSARTHandle)
{
  /* Prevent unused argument(s) compilation warning */
  UNUSED(pUSARTHandle);
  /* NOTE: This function should not be modified, when the callback is needed,
           the UART_MspInit could be implemented in the user file
   */
}


uint8_t UART_Transmit(UART_HandleTypeDef *pUSARTHandle, uint8_t *pData, uint16_t Size)
{
	uint16_t *tmp;

	// 1. Check that state of USARTx is READY
	if(pUSARTHandle->State != USART_STATE_READY)
	{
		// state of USARTx is not ready
		return pUSARTHandle->State;
	}

	// 2. Change state of USARTx to BUSY_TX
	pUSARTHandle->State = USART_STATE_BUSY_TX;

	// 3. Configure TxBufferSize, TxCount of USART Handler
	pUSARTHandle->TxXferSize = Size;
	pUSARTHandle->TxXferCount = Size;

	// 4. Write data to USART_DR until TxCount value reaches to zero
	while(pUSARTHandle->TxXferCount > 0U)
	{
		pUSARTHandle->TxXferCount--;

	    if (pUSARTHandle->Init.WordLength == UART_WORDLENGTH_9B)
	    {
	    	WAIT_FLAG_SET(pUSARTHandle->Instance->SR, USART_SR_TXE);

	        tmp = (uint16_t *) pData;
	        pUSARTHandle->Instance->DR = (*tmp & (uint16_t)0x01FF);

	        if (pUSARTHandle->Init.Parity == UART_PARITY_NONE)
	        {
	        	pData += 2U;
	        }
	        else
	        {
	        	pData += 1U;
	        }
	    }

	    else
	    {
	    	WAIT_FLAG_SET(pUSARTHandle->Instance->SR, USART_SR_TXE);

	    	pUSARTHandle->Instance->DR = (*pData++ & (uint8_t)0xFF);
	    }
	}

	// 5. Wait until TC flag is set in the SR
	WAIT_FLAG_SET(pUSARTHandle->Instance->SR, USART_SR_TC);

	// 6. Change state of USARTx to READY
	pUSARTHandle->State = USART_STATE_READY;

	return pUSARTHandle->State;
}


uint8_t UART_Transmit_IT(UART_HandleTypeDef *pUSARTHandle, uint8_t *pData, uint16_t Size)
{
	// 1. Check that state of USARTx is READY
	if(pUSARTHandle->State != USART_STATE_READY)
	{
		// state of USARTx is not ready
		return pUSARTHandle->State;
	}

	// 2. Change state of USARTx to BUSY_TX
	pUSARTHandle->State = USART_STATE_BUSY_TX;

	// 3. Configure TxBufferPointer, TxBufferSize, TxCount of USART Handler
	pUSARTHandle->pTxBuffPtr = pData;
	pUSARTHandle->TxXferSize = Size;
	pUSARTHandle->TxXferCount = Size;

	// 4. Enable USART TXE, TC interrupt
    UART_ENABLE_IT(pUSARTHandle, UART_IT_TXE);
    UART_ENABLE_IT(pUSARTHandle, UART_IT_TC);

	return pUSARTHandle->State;
}


void UART_Transmit_DMA(UART_HandleTypeDef *pUSARTHandle, uint8_t *pData, uint16_t Size)
{
	uint32_t *tmp;

	if(pUSARTHandle->State == USART_STATE_READY)
	{
		pUSARTHandle->pTxBuffPtr = pData;
		pUSARTHandle->TxXferSize = Size;
		pUSARTHandle->TxXferCount = Size;

		pUSARTHandle->State = USART_STATE_BUSY_TX;

	    /* Set the UART DMA transfer complete callback */
		pUSARTHandle->hdmatx->XferCpltCallback = UART_DMATransmitCplt;

	    /* Enable the UART transmit DMA stream */
	    tmp = (uint32_t *)&pData;
	    DMA_Start_IT(pUSARTHandle->hdmatx, *(uint32_t *)tmp, (uint32_t)&pUSARTHandle->Instance->DR, Size);

	    /* Clear the TC flag in the SR register by writing 0 to it */
	    UART_CLEAR_FLAG(pUSARTHandle, UART_FLAG_TC);

	    /* Enable the DMA transfer for transmit request by setting the DMAT bit
	       in the UART CR3 register */
	    SET_BIT(pUSARTHandle->Instance->CR3, USART_CR3_DMAT);
	}
}


__weak void USART_ApplicationEventCallback(UART_HandleTypeDef *pUSARTHandle, uint8_t AppEV)
{
	/* Prevent unused argument(s) compilation warning */
		UNUSED(pUSARTHandle);
		UNUSED(AppEV);

	/* NOTE : This function should not be modified, when the callback is needed,
	 * 		  the USART_ApplicationEventCallback could be implemented in the user file
	 * 		  (This is a weak implementation. The user application may override this function)
	 */
}


void UART_IRQHandler(UART_HandleTypeDef *pUSARTHandle)
{
	// Interrupt handling for USART

	uint32_t temp1, temp2;

	// 1. Handle for interrupt generated by TC event
	temp1 = READ_BIT(pUSARTHandle->Instance->SR, USART_SR_TC);
	temp2 = READ_BIT(pUSARTHandle->Instance->CR1, USART_CR1_TCIE);

	if(temp1 && temp2)
	{
		// This interrupt is generated by TC event

		// In this block, Close transmission and call application callback if TxCount is zero
		if(pUSARTHandle->State == USART_STATE_BUSY_TX)
		{
			// Check the TxCount. If it is zero, then close the data transmission
			if(pUSARTHandle->TxXferCount == 0)
			{
				// Clear the TC flag
				CLEAR_BIT(pUSARTHandle->Instance->SR, USART_SR_TC);

				// Clear the TCIE flag (Disable interrupt for TC flag)
				CLEAR_BIT(pUSARTHandle->Instance->CR1, USART_CR1_TCIE);

				// Reset the application state
				pUSARTHandle->State = USART_STATE_READY;

				// Reset TxBufferPointer to NULL
				pUSARTHandle->pTxBuffPtr = NULL;

				// Reset the TxBufferSize, TxCount to zero
				pUSARTHandle->TxXferSize = 0;
				pUSARTHandle->TxXferCount = 0;

				// Call the application callback with event USART_EVENT_TX_CMPLT
				USART_ApplicationEventCallback(pUSARTHandle, USART_EVENT_TX_CMPLT);
			}
		}
	}


	// 2. Handle for interrupt generated by TXE event
	temp1 = READ_BIT(pUSARTHandle->Instance->SR, USART_SR_TXE);
	temp2 = READ_BIT(pUSARTHandle->Instance->CR1, USART_CR1_TXEIE);

	if(temp1 && temp2)
	{
		// This interrupt is generated by TXE event

		if(pUSARTHandle->State == USART_STATE_BUSY_TX)
		{
			// Keep transmitting data until TxCount reaches to zero
			if(pUSARTHandle->TxXferCount > 0)
			{
				pUSARTHandle->Instance->DR = (uint8_t)(*pUSARTHandle->pTxBuffPtr & 0xFF);

				pUSARTHandle->pTxBuffPtr++;
				pUSARTHandle->TxXferCount--;
			}

			if(pUSARTHandle->TxXferCount == 0)
			{
				// TxCount is zero
				// Clear the TXEIE bit (Disable interrupt for TXE flag)
				CLEAR_BIT(pUSARTHandle->Instance->CR1, USART_CR1_TXEIE);
			}

		}

	}
}


static void UART_SetConfig(UART_HandleTypeDef *pUSARTHandle)
{
	uint32_t tmpreg;
	uint32_t pclk;

	/*-------------------------- USART CR2 Configuration -----------------------*/
	MODIFY_REG(pUSARTHandle->Instance->CR2, USART_CR2_STOP, pUSARTHandle->Init.StopBits);

	/*-------------------------- USART CR1 Configuration -----------------------*/
	tmpreg = (uint32_t)pUSARTHandle->Init.WordLength | pUSARTHandle->Init.Parity | pUSARTHandle->Init.Mode | pUSARTHandle->Init.OverSampling;
	MODIFY_REG(pUSARTHandle->Instance->CR1,
			 (uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | USART_CR1_RE | USART_CR1_OVER8),
			 tmpreg);

	/*-------------------------- USART CR3 Configuration -----------------------*/
	MODIFY_REG(pUSARTHandle->Instance->CR3, (USART_CR3_RTSE | USART_CR3_CTSE), pUSARTHandle->Init.HwFlowCtl);

	/*-------------------------- USART BRR Configuration ---------------------*/
	if(pUSARTHandle->Init.OverSampling == UART_OVERSAMPLING_8)
	{
	    if ((pUSARTHandle->Instance == USART1) || (pUSARTHandle->Instance == USART6))
	    {
	    	pclk = RCC_GetPCLK2Freq();
	    	pUSARTHandle->Instance->BRR = UART_BRR_SAMPLING8(pclk, pUSARTHandle->Init.BaudRate);
	    }

	    else
	    {
	    	pclk = RCC_GetPCLK1Freq();
	    	pUSARTHandle->Instance->BRR = UART_BRR_SAMPLING8(pclk, pUSARTHandle->Init.BaudRate);
	    }
	}

	else
	{
	    if ((pUSARTHandle->Instance == USART1) || (pUSARTHandle->Instance == USART6))
	    {
	    	pclk = RCC_GetPCLK2Freq();
	    	pUSARTHandle->Instance->BRR = UART_BRR_SAMPLING16(pclk, pUSARTHandle->Init.BaudRate);
	    }
	    else
	    {
	    	pclk = RCC_GetPCLK1Freq();
	    	pUSARTHandle->Instance->BRR = UART_BRR_SAMPLING16(pclk, pUSARTHandle->Init.BaudRate);
	    }
	}
}


static void UART_DMATransmitCplt(DMA_HandleTypeDef *pDMAHandle)
{
	UART_HandleTypeDef *pUSARTHandle = (UART_HandleTypeDef *)((DMA_HandleTypeDef *)pDMAHandle)->Parent;

	/* DMA Normal mode*/
	if((pDMAHandle->Instance->CR & DMA_SxCR_CIRC) == 0U)
	{
		pUSARTHandle->TxXferCount = 0x00U;

	    /* Disable the DMA transfer for transmit request by setting the DMAT bit
	       in the UART CR3 register */

		CLEAR_BIT(pUSARTHandle->Instance->CR3, USART_CR3_DMAT);

	    /* Enable the UART Transmit Complete Interrupt */
	    SET_BIT(pUSARTHandle->Instance->CR1, USART_CR1_TCIE);
	}

}










